Managing code is a pain. This will hopefully bridge the gap, somewhat. The idea is gather metadata about projects in the users Coding directory.

- [x] Python script
- [ ] Loads information from ~/Coding/.mpidentity
		- what usernames/email addresses/names belong to the person who owns ~/Coding/
- [x] Iterates through folders in ~/Coding/ tree.
- [x] Store the resulting information in a list
	- Dictionaries containing the project directory name
		- [x] Relative path from ~/Coding
		- [ ] To determine if a folder is a project, uses cues like files/folders named .git, .gitignore, node_modules, venv*, pycache (or whatever the equivalent is), package.json, package-lock.json, requirements.txt
		- [x] Does not recurse into node_modules, pycache, etc., type folders
		- [ ] loads files/folders to ignore from ~/Coding/.mpignore like git does .gitignore)
		- [ ] Checks the git status of each project folder
			- [ ] "missing" (no git)
			- [ ] "modified" (unsaved changes / files)
			- [ ] "no-remote" (local project only)
			- [ ] "remote-out-of-date" (local has changes that haven’t been pushed)
			- [ ] "up-to-date" (local and remote are in sync)
		- [ ] If project has git, figures out if owner of ~/Coding/ is part of git history for it, sets a boolean in the dictionary for this project (owner_is_dev)
		- [ ] If the project has a README.md (and it’s >0 bytes) (if owner_is_dev)
		- [ ] If the project has a LICENSE.* file (if owner_is_dev)
		- [ ] latest_timestamp with the timestamp of the most recently modified file in that project (outside of pycache, node_modules, or other files not directly created by the actions of the dev)
		- [ ] For folders with a venv*, it will check if there's a requirements.txt
		- [ ] If it’s a stray script or program file, mark it as a scrap
	- [ ] An configurable age limit for when a project should be considered part of
		- [ ] archived
		- [ ] inactive
		- [ ] active
	- [ ] A list of names for educational / challenge sites
	- [ ] If there are project name duplications, or duplicate names of files without a project, set a boolean for duplicated_name
	- [ ] Or, maybe output it as XLS or CSV

	- [ ] In write mode:
		- [ ] If the project isn’t owned by the user and it’s not in the Git or External folder, offer to move it there
		- [ ] If the project is in the active range, and it’s not in the active folder, offer to move it there
		- [ ] If the  project is in the active range, offer to symlink it into ~/Coding/
		- [ ] If the project is older than the archive date and it’s not in the archive folder, offer to move it there
		- [ ] If the symlinked projects are in the archive range, offer to remove the symlinks
		- [ ] Offer to move scraps to the scrap folder
		- [ ] If it’s technically inactive but gets moved to Archived, then let it stay in Archived.
		- [ ] Inactive is the in between like, updated this week and not touched in 3 months.
		- [ ] I’d also like a way to have it move a project out of Archive via the command-line symlinking to it in the root coding directory.
		- [ ] Challenges should be offered up in a similar way.
